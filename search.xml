<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用jdbc模板实现增删改查</title>
      <link href="/2020/03/13/%E4%BD%BF%E7%94%A8jdbc%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/2020/03/13/%E4%BD%BF%E7%94%A8jdbc%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="使用jdbc模板实现增删改查"><a href="#使用jdbc模板实现增删改查" class="headerlink" title="使用jdbc模板实现增删改查"></a>使用jdbc模板实现增删改查</h2><pre><code class="java">public class UserDaoImpl implements UserDao {    private JdbcTemplate jt;    @Override    public void save(User u) {        String sql = &quot;insert into t_user values(null,?)&quot;;        jt.update(sql, u.getName());    }    @Override    public void delete(Integer id) {        String sql = &quot;delete from t_user where id = ? &quot;;        jt.update(sql, id);    }    @Override    public void update(User u) {        String sql = &quot;update  t_user set name = ? where id=? &quot;;        jt.update(sql, u.getName(), u.getId());    }    @Override    public User getById(Integer id) {        String sql = &quot;select * from t_user where id = ? &quot;;        return jt.queryForObject(sql, new RowMapper&lt;User&gt;() {            @Override            public User mapRow(ResultSet rs, int arg1) throws SQLException {                User u = new User();                u.setId(rs.getInt(&quot;id&quot;));                u.setName(rs.getString(&quot;name&quot;));                return u;            }        }, id);    }    @Override    public int getTotalCount() {        String sql = &quot;select count(*) from t_user &quot;;        Integer count = jt.queryForObject(sql, Integer.class);        return count;    }    @Override    public List&lt;User&gt; getAll() {        String sql = &quot;select * from t_user&quot;;        List&lt;User&gt; list = jt.query(sql, new RowMapper&lt;User&gt;() {            @Override            public User mapRow(ResultSet rs, int arg1) throws SQLException {                User u = new User();                u.setId(rs.getInt(&quot;id&quot;));                u.setName(rs.getString(&quot;name&quot;));                return u;            }        });        return list;    }    public JdbcTemplate getJt() {        return jt;    }    public void setJt(JdbcTemplate jt) {        this.jt = jt;    }}</code></pre><h2 id="xml配置文件"><a href="#xml配置文件" class="headerlink" title="xml配置文件"></a>xml配置文件</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-4.2.xsd     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;    &lt;!-- 指定spring读取db.properties配置 --&gt;    &lt;context:property-placeholder        location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 1.将连接池放入spring容器 --&gt;    &lt;bean name=&quot;dataSource&quot;        class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 2.将JDBCTemplate放入spring容器 --&gt;    &lt;bean name=&quot;jdbcTemplate&quot;        class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 3.将UserDao放入spring容器 --&gt;    &lt;bean name=&quot;userDao&quot; class=&quot;cn.itcast.a_jdbctemplate.UserDaoImpl&quot;&gt;        &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h4 id="在UserDaoImpl使用继承JdbcDaoSupport，即根据连接池创建JDBC模板，即可不需要手动准备JDBC模板，’从父类方法中获得即可（super-getJdbcTemplate-），如下："><a href="#在UserDaoImpl使用继承JdbcDaoSupport，即根据连接池创建JDBC模板，即可不需要手动准备JDBC模板，’从父类方法中获得即可（super-getJdbcTemplate-），如下：" class="headerlink" title="在UserDaoImpl使用继承JdbcDaoSupport，即根据连接池创建JDBC模板，即可不需要手动准备JDBC模板，’从父类方法中获得即可（super.getJdbcTemplate()），如下："></a>在UserDaoImpl使用继承JdbcDaoSupport，即根据连接池创建JDBC模板，即可不需要手动准备JDBC模板，’从父类方法中获得即可（super.getJdbcTemplate()），如下：</h4><pre><code class="java">public class UserDaoImpl extends JdbcDaoSupport implements UserDao {    @Override    public void save(User u) {        String sql = &quot;insert into t_user values(null,?)&quot;;        super.getJdbcTemplate().update(sql, u.getName());    }    @Override    public void delete(Integer id) {        String sql = &quot;delete from t_user where id = ? &quot;;        super.getJdbcTemplate().update(sql, id);    }    @Override    public void update(User u) {        String sql = &quot;update  t_user set name = ? where id=? &quot;;        super.getJdbcTemplate().update(sql, u.getName(), u.getId());    }    @Override    public User getById(Integer id) {        String sql = &quot;select * from t_user where id = ? &quot;;        return super.getJdbcTemplate().queryForObject(sql, new RowMapper&lt;User&gt;() {            @Override            public User mapRow(ResultSet rs, int arg1) throws SQLException {                User u = new User();                u.setId(rs.getInt(&quot;id&quot;));                u.setName(rs.getString(&quot;name&quot;));                return u;            }        }, id);    }    @Override    public int getTotalCount() {        String sql = &quot;select count(*) from t_user &quot;;        Integer count = super.getJdbcTemplate().queryForObject(sql, Integer.class);        return count;    }    @Override    public List&lt;User&gt; getAll() {        String sql = &quot;select * from t_user&quot;;        List&lt;User&gt; list = super.getJdbcTemplate().query(sql, new RowMapper&lt;User&gt;() {            @Override            public User mapRow(ResultSet rs, int arg1) throws SQLException {                User u = new User();                u.setId(rs.getInt(&quot;id&quot;));                u.setName(rs.getString(&quot;name&quot;));                return u;            }        });        return list;    }}</code></pre><h2 id="修改xml配置文件"><a href="#修改xml配置文件" class="headerlink" title="修改xml配置文件"></a>修改xml配置文件</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-4.2.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;    &lt;!-- 指定spring读取db.properties配置 --&gt;    &lt;context:property-placeholder        location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 1.将连接池放入spring容器 --&gt;    &lt;bean name=&quot;dataSource&quot;        class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 2.将JDBCTemplate放入spring容器 --&gt;&lt;!--     &lt;bean name=&quot;jdbcTemplate&quot; --&gt;&lt;!--         class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; --&gt;&lt;!--         &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; --&gt;&lt;!--     &lt;/bean&gt; --&gt;    &lt;!-- 3.将UserDao放入spring容器 --&gt;    &lt;bean name=&quot;userDao&quot; class=&quot;cn.itcast.a_jdbctemplate.UserDaoImpl&quot;&gt;        &lt;!-- &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; --&gt;        &lt;!-- 根据连接池创建JDBC模板 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的基本配置及注入方式</title>
      <link href="/2017/03/23/Spring%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/03/23/Spring%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="xml文件的配置"><a href="#xml文件的配置" class="headerlink" title="xml文件的配置"></a>xml文件的配置</h2><pre><code class="xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;&gt;        &lt;!-- 将User对象交给spring容器管理 --&gt;        &lt;!-- Bean元素:使用该元素描述需要spring容器管理的对象         class属性:被管理对象的完整类名.          name属性:给被管理的对象起个名字.获得对象时根据该名称获得对象.                     可以重复.可以使用特殊字符.         id属性: 与name属性一模一样.                      名称不可重复.不能使用特殊字符.          结论: 尽量使用name属性. --&gt;          &lt;bean name=&quot;user&quot; class=&quot;cn.itcast.bean.User&quot;&gt;          &lt;/bean&gt;    &lt;/beans&gt;</code></pre><hr><h2 id="调用Spring"><a href="#调用Spring" class="headerlink" title="调用Spring"></a>调用Spring</h2><pre><code class="java">public class Demo {    @Test    public void fun1() {        //1. 创建容器对象        //ClassPathXmlApplicationContext--从类路径下加载配置文件        ApplicationContext ac =         new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //2.向容器要User对象        User u = (User) ac.getBean(&quot;user&quot;);        //3. 打印User对象        System.out.println(u);    }}</code></pre><hr><h3 id="spring创建对象的方式"><a href="#spring创建对象的方式" class="headerlink" title="spring创建对象的方式"></a>spring创建对象的方式</h3><ol><li>空参构造方式<pre><code class="xml"> &lt;!-- 创建方式1:空参构造创建  --&gt; &lt;bean  name=&quot;user&quot; class=&quot;cn.itcast.bean.User&quot; &gt;&lt;/bean&gt;</code></pre></li></ol><hr><ol start="2"><li>静态工厂(了解)</li></ol><pre><code class="java">    public static User createUser() {        System.out.println(&quot;静态工厂创建User&quot;);        return new User();    }</code></pre><pre><code class="xml">    &lt;!-- 创建方式2:静态工厂创建 调用UserFactory的createUser方法    创建名为user2的对象，放入容器 --&gt;    &lt;bean name=&quot;user2&quot; class=&quot;cn.itcast.b_create.UserFactory&quot;        factory-method=&quot;createUser&quot;&gt;&lt;/bean&gt;</code></pre><hr><ol start="3"><li>实例工厂(了解)</li></ol><pre><code class="java">    public User createUser2() {        System.out.println(&quot;实例工厂创建User&quot;);        return new User();    }</code></pre><pre><code class="xml">    &lt;!-- 创建方式3:实例工厂创建 调用UserFactory对象的createUser2方法    创建名为user3的对象.放入容器 --&gt;    &lt;bean name=&quot;user3&quot; factory-bean=&quot;userFactory&quot;        factory-method=&quot;createUser2&quot;&gt;&lt;/bean&gt;    &lt;bean name=&quot;userFactory&quot; class=&quot;cn.itcast.b_create.UserFactory&quot;&gt;&lt;/bean&gt;</code></pre><hr><ol start="4"><li>生命周期属性</li></ol><pre><code class="xml">&lt;!-- init-method：配置一个方法作为生命周期初始化方法.spring会在对象创建之后立即调用 --&gt;&lt;!--destory-method：配置一个方法作为生命周期的销毁方法.spring容器在关闭并销毁所有容器中的对象之前调用. --&gt;&lt;bean name=&quot;user&quot; class=&quot;cn.itcast.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt;&lt;/bean&gt;</code></pre><hr><h2 id="分模块配置"><a href="#分模块配置" class="headerlink" title="分模块配置"></a>分模块配置</h2><pre><code class="xml">&lt;!-- 导入其他spring配置文件 --&gt;&lt;import resource=&quot;cn/itcast/b_create/applicationContext.xml&quot;/&gt;</code></pre><hr><h2 id="Spring属性注入"><a href="#Spring属性注入" class="headerlink" title="Spring属性注入"></a>Spring属性注入</h2><ol><li>set方法注入<pre><code class="xml">&lt;!-- set方式注入: --&gt;&lt;bean  name=&quot;user&quot; class=&quot;cn.itcast.bean.User&quot; &gt;&lt;!-- 值类型注入：为User对象中名为name的属性注入tom为值 --&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;!-- 引用类型注入：为car属性注入下方配置的car对象 --&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将Car对象配置到容器中  --&gt;&lt;bean name=&quot;car&quot; class=&quot;cn.itcast.bean.Car&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;兰博基尼&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ol><hr><ol start="2"><li>构造函数注入<pre><code class="xml">&lt;!-- 构造函数注入 --&gt;&lt;!-- name属性: 构造函数的参数名 --&gt;&lt;!-- index属性: 构造函数的参数索引 --&gt;&lt;!-- type属性: 构造函数的参数类型--&gt;&lt;bean name=&quot;user2&quot; class=&quot;cn.itcast.bean.User&quot;&gt; &lt;!-- index用于选择参数的位置（即确定调用哪个构造函数） --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;jerry&quot; index=&quot;0&quot;&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; index=&quot;1&quot;&gt; &lt;/constructor-arg&gt; &lt;!-- type用于确定当调用相同参数位置 ，但类型不同时调用哪个构造函数 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;999&quot; index=&quot;0&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; index=&quot;1&quot;&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre></li></ol><hr><ol start="3"><li>p名称空间注入<pre><code class="xml"> &lt;!-- p名称空间注入, 走set方法     1.导入P名称空间 xmlns:p=&quot;http://www.springframework.org/schema/p&quot;      2.使用p:属性完成注入 |-值类型: p:属性名=&quot;值&quot; |-对象类型: p:属性名-ref=&quot;bean名称&quot;  --&gt; &lt;bean name=&quot;user3&quot; class=&quot;cn.itcast.bean.User&quot; p:name=&quot;jack&quot;     p:age=&quot;20&quot; p:car-ref=&quot;car&quot;&gt; &lt;/bean&gt;</code></pre></li></ol><hr><ol start="4"><li>spel注入</li></ol><pre><code class="xml">&lt;!--         spel注入: spring Expression Language sping表达式语言 --&gt;     &lt;bean name=&quot;user4&quot; class=&quot;cn.itcast.bean.User&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;#{user.name}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;#{user3.age}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><hr><ol start="5"><li>复杂类型的注入</li></ol><pre><code class="xml">&lt;!-- 复杂类型注入 --&gt;&lt;bean name=&quot;cb&quot; class=&quot;cn.itcast.c_injection.CollectionBean&quot; &gt;    &lt;!-- 如果数组中只准备注入一个值(对象),直接使用value|ref即可     &lt;property name=&quot;arr&quot; value=&quot;tom&quot; &gt;&lt;/property&gt;    --&gt;    &lt;!-- array注入,多个元素注入 --&gt;    &lt;property name=&quot;arr&quot;&gt;        &lt;array&gt;            &lt;value&gt;tom&lt;/value&gt;            &lt;value&gt;jerry&lt;/value&gt;            &lt;ref bean=&quot;user4&quot; /&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!-- 如果List中只准备注入一个值(对象),直接使用value|ref即可     &lt;property name=&quot;list&quot; value=&quot;jack&quot; &gt;&lt;/property&gt;--&gt;    &lt;property name=&quot;list&quot;  &gt;        &lt;list&gt;            &lt;value&gt;jack&lt;/value&gt;            &lt;value&gt;rose&lt;/value&gt;            &lt;ref bean=&quot;user3&quot; /&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- map类型注入 --&gt;    &lt;property name=&quot;map&quot;  &gt;        &lt;map&gt;            &lt;entry key=&quot;url&quot; value=&quot;jdbc:mysql:///crm&quot; &gt;&lt;/entry&gt;            &lt;entry key=&quot;user&quot; value-ref=&quot;user4&quot;  &gt;&lt;/entry&gt;            &lt;entry key-ref=&quot;user3&quot; value-ref=&quot;user2&quot;  &gt;&lt;/entry&gt;        &lt;/map&gt;     &lt;/property&gt;    &lt;!-- prperties 类型注入 --&gt;    &lt;property name=&quot;prop&quot;  &gt;        &lt;props&gt;            &lt;prop key=&quot;driverClass&quot;&gt;com.jdbc.mysql.Driver&lt;/prop&gt;            &lt;prop key=&quot;userName&quot;&gt;root&lt;/prop&gt;            &lt;prop key=&quot;password&quot;&gt;1234&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring通知类型</title>
      <link href="/2017/03/23/Spring%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/03/23/Spring%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="xml定义通知"><a href="#xml定义通知" class="headerlink" title="xml定义通知"></a>xml定义通知</h3><p>定义通知类</p><pre><code class="java">//通知类public class MyAdvice {    // 前置通知//            |-目标方法之前调用    // 后置通知（如果出现异常不会调用）//            |-目标方法之后调用    // 环绕通知//            |-目标方法之前和之后调用    // 异常拦截通知//            |-如果出现异常，就会调用    // 后置通知（无论是否出现异常都会调用）//            |-目标方法之后调用//    前置通知    public void before() {        System.out.println(&quot;这是前置通知！！&quot;);    }//    后置通知    public void afterReturning() {        System.out.println(&quot;这是后置通知（如果出现异常不会调用）！！&quot;);    }//    环绕通知    private Object around(ProceedingJoinPoint pjp) throws Throwable {        System.out.println(&quot;这是环绕通知之前的部分！！！&quot;);        Object proceed = pjp.proceed();// 调用目标方法        System.out.println(&quot;这是环绕通知之后的部分！！！&quot;);        return proceed;    }//    异常通知    public void afterException() {        System.out.println(&quot;出事！！！出现异常了！！&quot;);    }//    后置通知    public void after() {        System.out.println(&quot;这是后置通知（出现异常也会调用）！！&quot;);    }}</code></pre><hr><p>xml文件配置</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;&gt;    &lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;    &lt;!-- 1.配置目标对象 --&gt;    &lt;bean name=&quot;userService&quot; class=&quot;cn.itcast.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;    &lt;!-- 2.配置通知对象 --&gt;    &lt;bean name=&quot;myAdvice&quot; class=&quot;cn.itcast.d_springaop.MyAdvice&quot;&gt;&lt;/bean&gt;    &lt;!-- 3.配置将通知织入目标对象 --&gt;    &lt;aop:config&gt;        &lt;!-- 配置切入点             public void cn.itcast.service.UserServiceImpl.save()             void cn.itcast.service.UserServiceImpl.save()             * cn.itcast.service.UserServiceImpl.save()            * cn.itcast.service.UserServiceImpl.*()             * cn.itcast.service.*ServiceImpl.*(..)             * cn.itcast.service..*ServiceImpl.*(..)         --&gt;        &lt;aop:pointcut            expression=&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;            id=&quot;pc&quot; /&gt;        &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;            &lt;!-- 指定名为before方法作为前置通知 --&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pc&quot; /&gt;            &lt;!-- 后置 --&gt;            &lt;aop:after-returning method=&quot;afterReturning&quot;                pointcut-ref=&quot;pc&quot; /&gt;            &lt;!-- 环绕通知 --&gt;            &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pc&quot; /&gt;            &lt;!-- 异常拦截通知 --&gt;            &lt;aop:after-throwing method=&quot;afterException&quot;                pointcut-ref=&quot;pc&quot; /&gt;            &lt;!-- 后置 --&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pc&quot; /&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><hr><p>UserServiceImpl</p><pre><code class="java">package cn.itcast.service;public class UserServiceImpl implements UserService {    @Override    public void save() {        System.out.println(&quot;保存用户!&quot;);//        int i = 1/0;    }    @Override    public void delete() {        System.out.println(&quot;删除用户!&quot;);    }    @Override    public void update() {        System.out.println(&quot;更新用户!&quot;);    }    @Override    public void find() {        System.out.println(&quot;查找用户!&quot;);    }}</code></pre><hr><h3 id="注解方式定义通知"><a href="#注解方式定义通知" class="headerlink" title="注解方式定义通知"></a>注解方式定义通知</h3><p>xml文件配置</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;&gt;    &lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;    &lt;!-- 1.配置目标对象 --&gt;    &lt;bean name=&quot;userService&quot; class=&quot;cn.itcast.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;    &lt;!-- 2.配置通知对象 --&gt;    &lt;bean name=&quot;myAdvice&quot; class=&quot;cn.itcast.e_annotationaop.MyAdvice&quot;&gt;&lt;/bean&gt;    &lt;!-- 3.开启使用注解完成织入 --&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><hr><p>定义通知类：</p><pre><code class="java">//通知类@Aspect//表示该类是一个通知类public class MyAdvice {    @Pointcut(&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;)    public void pc() {    }//    前置通知    // 指定该方法是前置通知,并制定切入点    @Before(&quot;MyAdvice.pc()&quot;)    public void before() {        System.out.println(&quot;这是前置通知！！&quot;);    }//    后置通知    @AfterReturning(&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;)    public void afterReturning() {        System.out.println(&quot;这是后置通知（如果出现异常不会调用）！！&quot;);    }//    环绕通知    @Around(&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;)    private Object around(ProceedingJoinPoint pjp) throws Throwable {        System.out.println(&quot;这是环绕通知之前的部分！！！&quot;);        Object proceed = pjp.proceed();// 调用目标方法        System.out.println(&quot;这是环绕通知之后的部分！！！&quot;);        return proceed;    }//    异常通知    @AfterThrowing(&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;)    public void afterException() {        System.out.println(&quot;出事！！！出现异常了！！&quot;);    }//    后置通知    @After(&quot;execution(* cn.itcast.service.*ServiceImpl.*(..))&quot;)    public void after() {        System.out.println(&quot;这是后置通知（出现异常也会调用）！！&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC四大配置文件整合</title>
      <link href="/2017/03/23/%E6%95%B4%E5%90%88MyBatis%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2017/03/23/%E6%95%B4%E5%90%88MyBatis%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="sqlMapConfig-xml"><a href="#sqlMapConfig-xml" class="headerlink" title="sqlMapConfig.xml"></a>sqlMapConfig.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 设置别名 --&gt;    &lt;typeAliases&gt;        &lt;!-- 2. 指定扫描包，会把包内所有的类都设置别名，别名的名称就是类名，大小写不敏感 --&gt;        &lt;package name=&quot;com.itheima.springmvc.pojo&quot; /&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;</code></pre><hr><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- Mybatis的工厂 --&gt;    &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;!-- 核心配置文件的位置 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:sqlMapConfig.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Mapper动态代理开发   扫描 --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 基本包 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.springmvc.dao&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 注解事务 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启注解 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><hr><h3 id="springmvc-xml"><a href="#springmvc-xml" class="headerlink" title="springmvc.xml"></a>springmvc.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;!-- 扫描@Controler @Service --&gt;    &lt;context:component-scan        base-package=&quot;com.itheima&quot; /&gt;    &lt;!-- 处理器映射器 --&gt;    &lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; --&gt;    &lt;!-- 处理器适配器 --&gt;    &lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; --&gt;    &lt;!-- 注解驱动 --&gt;    &lt;mvc:annotation-driven        conversion-service=&quot;conversionServiceFactoryBean&quot; /&gt;    &lt;!-- 配置Conveter转换器 转换工厂 （日期、去掉前后空格）。。 --&gt;    &lt;bean id=&quot;conversionServiceFactoryBean&quot;        class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;        &lt;!-- 配置 多个转换器 --&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;list&gt;                &lt;bean class=&quot;com.itheima.springmvc.conversion.DateConveter&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 视图解释器 --&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;    &lt;display-name&gt;springmvc-mybatis&lt;/display-name&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- Spring监听器 --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- 处理POST提交乱码问题 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!-- 前端控制器 --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 默认找 /WEB-INF/[servlet的名称]-servlet.xml --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;!-- 1. /* 拦截所有 jsp js png .css 真的全拦截 建议不使用              2. *.action *.do 拦截以do action 结尾的请求 肯定能使用 ERP              3. / 拦截所有 （不包括jsp) (包含.js .png.css) 强烈建议使用 前台 面向消费者 www.jd.com/search             /对静态资源放行 --&gt;        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java创建一个对象内存图</title>
      <link href="/2017/03/14/%E5%86%85%E5%AD%98%E5%9B%BE/"/>
      <url>/2017/03/14/%E5%86%85%E5%AD%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="一个对象的内存图："><a href="#一个对象的内存图：" class="headerlink" title="一个对象的内存图："></a>一个对象的内存图：</h3><p><img src="https://raw.githubusercontent.com/MisayaQ/LocalImg/master/neicun1.png" alt="单个对象的内存图"><br>解析：    </p><p>根据程序，方法区先加载class，两个class分别为Phone.class（加载成员变量和成员方法）  和 Demo01PhoneOne.class</p><p>程序运行，先运行main方法，所以main方法进栈（压栈），</p><p>创建对象，Phone one ，右边 new Phone（）—–new的对象都在堆里面，</p><p>在堆里面加载一个Phone对象，并且加载成员变量和成员方法，</p><p>系统为成员变量赋初值，这里注意，成员变量参照方法区里面的成员变量创建，初始值就保存在堆里。</p><p>但是成员方法保存的是一个地址值（绿色为成员方法地址值）指向右边的方法区。</p><p>同理堆里面创建好的Phone也有自己的地址值（红色为创建对象Phone的地址值）</p><p>Phone one = new Phone（）意思即为把 “堆内存的Phone” 赋值给“栈内存里面的one”，所以栈内存通过地址值指向堆内存。</p><p>当赋值完成后，改变成员变量的值，one.brand = “苹果” ，根据one先确自己的地址值，指向对应的堆内存，改变堆内存成员变量的初始值。</p><p>之后调用成员方法call()时，先根据one先确自己的地址值，指向对应的堆内存，根据成员方法的地址，再指向方法区，经过两步！</p><p>找到想要调用的成员方法后，调用的方法进栈（压栈），根据进栈原则（先进后出、后进先出）</p><p>方法call()调用结束后出栈（从栈内存消失），之后同理调用下一个成员方法sendMessage(），方法同上操作后，进栈，方法sendMessage()调用结束后出栈（从栈内存消失），最后main()方法运行结束，main方法出栈，内存清空。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 对象封装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
